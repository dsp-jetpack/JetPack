--- /usr/lib/python2.7/site-packages/dracclient/wsman.py	2017-01-25 11:33:50.386480887 -0500
+++ wsman.py	2017-03-10 13:53:56.943877064 -0500
@@ -15,7 +15,6 @@
 import uuid
 
 from lxml import etree as ElementTree
-import requests
 import requests.exceptions
 
 from dracclient import exceptions
@@ -36,6 +35,8 @@
 FILTER_DIALECT_MAP = {'cql': 'http://schemas.dmtf.org/wbem/cql/1/dsp0202.pdf',
                       'wql': 'http://schemas.microsoft.com/wbem/wsman/1/WQL'}
 
+RETRIES = 3
+
 
 class Client(object):
     """Simple client for talking over WSMan protocol."""
@@ -58,16 +59,36 @@
         payload = payload.build()
         LOG.debug('Sending request to %(endpoint)s: %(payload)s',
                   {'endpoint': self.endpoint, 'payload': payload})
-        try:
-            resp = requests.post(
-                self.endpoint,
-                auth=requests.auth.HTTPBasicAuth(self.username, self.password),
-                data=payload,
-                # TODO(ifarkas): enable cert verification
-                verify=False)
-        except requests.exceptions.RequestException:
-            LOG.exception('Request failed')
-            raise exceptions.WSManRequestFailure()
+
+        retries = 1
+        while retries <= RETRIES:
+            try:
+                resp = requests.post(
+                    self.endpoint,
+                    auth=requests.auth.HTTPBasicAuth(self.username,
+                                                     self.password),
+                    data=payload,
+                    # TODO(ifarkas): enable cert verification
+                    verify=False)
+                break
+            except (requests.exceptions.ConnectionError,
+                    requests.exceptions.SSLError) as ex:
+                LOG.warn("A {} error occurred while communicating"
+                         " with {}, attempt {} of {}".format(
+                             type(ex).__name__,
+                             self.host,
+                             retries,
+                             RETRIES))
+
+                if retries == RETRIES:
+                    LOG.exception('Request failed')
+                    raise exceptions.WSManRequestFailure()
+
+                retries += 1
+
+            except requests.exceptions.RequestException:
+                LOG.exception('Request failed')
+                raise exceptions.WSManRequestFailure()
 
         LOG.debug('Received response from %(endpoint)s: %(payload)s',
                   {'endpoint': self.endpoint, 'payload': resp.content})
@@ -105,21 +126,23 @@
         resp_xml = ElementTree.fromstring(resp.content)
 
         if auto_pull:
-            find_items_query = './/{%s}Items' % NS_WSMAN_ENUM
+            # The first response returns "<wsman:Items>"
+            find_items_wsman_query = './/{%s}Items' % NS_WSMAN
+
+            # Successive pulls return "<wsen:Items>"
+            find_items_enum_query = './/{%s}Items' % NS_WSMAN_ENUM
+
             full_resp_xml = resp_xml
+            items_xml = full_resp_xml.find(find_items_wsman_query)
 
             context = self._enum_context(full_resp_xml)
             while context is not None:
                 resp_xml = self.pull(resource_uri, context, max_elems)
                 context = self._enum_context(resp_xml)
 
-                items_xml = full_resp_xml.find(find_items_query)
-                if items_xml is not None:
-                    # merge enumeration items
-                    for item in resp_xml.find(find_items_query):
-                        items_xml.append(item)
-                else:
-                    full_resp_xml = resp_xml
+                # Merge in next batch of enumeration items
+                for item in resp_xml.find(find_items_enum_query):
+                    items_xml.append(item)
 
             # remove enumeration context because items are already merged
             enum_context_elem = full_resp_xml.find('.//{%s}EnumerationContext'
