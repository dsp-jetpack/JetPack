--- client_orig_14may.py.orig	2019-05-14 06:15:53.291771851 -0400
+++ client_orig_14may.py	2019-06-04 05:49:42.711845066 -0400
@@ -33,7 +33,7 @@
 from dracclient import utils
 from dracclient import wsman
 
-IDRAC_IS_READY = "LC061"
+IDRAC_IS_READY = "0"
 
 LOG = logging.getLogger(__name__)
 
@@ -272,7 +272,7 @@
         state_reached = self._wait_for_host_state(
             self.client.host,
             alive=False,
-            ping_count=3,
+            ping_count=2,
             retries=24)
 
         if not state_reached:
@@ -468,7 +468,8 @@
                           cim_system_creation_class_name='DCIM_ComputerSystem',
                           cim_system_name='DCIM:ComputerSystem',
                           reboot=False,
-                          start_time='TIME_NOW'):
+                          start_time='TIME_NOW',
+                          realtime=False):
         """Creates a configuration job.
 
         In CIM (Common Information Model), weak association is used to name an
@@ -492,6 +493,8 @@
                            means execute immediately or None which means
                            the job will not execute until
                            schedule_job_execution is called
+        :param realtime: Indicates if reatime mode should be used.
+               Valid values are True and False.
         :returns: id of the created job
         :raises: WSManRequestFailure on request failures
         :raises: WSManInvalidResponse when receiving invalid response
@@ -508,7 +511,8 @@
             cim_system_creation_class_name=cim_system_creation_class_name,
             cim_system_name=cim_system_name,
             reboot=reboot,
-            start_time=start_time)
+            start_time=start_time,
+            realtime=realtime)
 
     def create_nic_config_job(
             self,
@@ -784,8 +788,52 @@
         """
         return self._raid_mgmt.delete_virtual_disk(virtual_disk)
 
+    def reset_raid_config(self, raid_controller):
+        """Delete all the virtual disks and unassign all hot spare physical disks
+
+        The job to reset the RAID controller config will be in pending state.
+        For the changes to be applied, a config job must be created.
+
+        :param raid_controller: id of the RAID controller
+        :returns: a dictionary containing:
+                 - The is_commit_required key with the value always set to
+                   True indicating that a config job must be created to
+                   reset configuration.
+                 - The is_reboot_required key with a RebootRequired enumerated
+                   value indicating whether the server must be rebooted to
+                   reset configuration.
+        :raises: WSManRequestFailure on request failures
+        :raises: WSManInvalidResponse when receiving invalid response
+        :raises: DRACOperationFailed on error reported back by the DRAC
+                 interface
+        :raises: DRACUnexpectedReturnValue on return value mismatch
+        """
+        return self._raid_mgmt.reset_raid_config(raid_controller)
+
+    def clear_foreign_config(self, raid_controller):
+        """Free up foreign drives
+
+        The job to clear foreign config will be in pending state.
+        For the changes to be applied, a config job must be created.
+
+        :param raid_controller: id of the RAID controller
+        :returns: a dictionary containing:
+                 - The is_commit_required key with the value always set to
+                   True indicating that a config job must be created to
+                   clear foreign configuration.
+                 - The is_reboot_required key with a RebootRequired enumerated
+                   value indicating whether the server must be rebooted to
+                   clear foreign configuration.
+        :raises: WSManRequestFailure on request failures
+        :raises: WSManInvalidResponse when receiving invalid response
+        :raises: DRACOperationFailed on error reported back by the DRAC
+                 interface
+        :raises: DRACUnexpectedReturnValue on return value mismatch
+        """
+        return self._raid_mgmt.clear_foreign_config(raid_controller)
+
     def commit_pending_raid_changes(self, raid_controller, reboot=False,
-                                    start_time='TIME_NOW'):
+                                    start_time='TIME_NOW', realtime=False):
         """Applies all pending changes on a RAID controller
 
          ...by creating a config job.
@@ -798,6 +846,8 @@
                means execute immediately or None which means
                the job will not execute until
                schedule_job_execution is called
+        :param realtime: Indicates if reatime mode should be used.
+               Valid values are True and False.
         :returns: id of the created job
         :raises: WSManRequestFailure on request failures
         :raises: WSManInvalidResponse when receiving invalid response
@@ -811,7 +861,8 @@
             cim_name='DCIM:RAIDService',
             target=raid_controller,
             reboot=reboot,
-            start_time=start_time)
+            start_time=start_time,
+            realtime=realtime)
 
     def abandon_pending_raid_changes(self, raid_controller):
         """Deletes all pending changes on a RAID controller
@@ -830,6 +881,14 @@
             cim_creation_class_name='DCIM_RAIDService',
             cim_name='DCIM:RAIDService', target=raid_controller)
 
+    def is_realtime_supported(self, raid_controller):
+        """Find if controller supports realtime or not
+
+        :param raid_controller: ID of RAID controller
+        :returns: True or False
+        """
+        return self._raid_mgmt.is_realtime_supported(raid_controller)
+
     def list_cpus(self):
         """Returns the list of CPUs
 
@@ -962,15 +1021,23 @@
         """
         return self._raid_mgmt.is_jbod_capable(raid_controller_fqdd)
 
-    def is_raid_controller(self, raid_controller_fqdd):
-        """Find out if object's fqdd is for a raid controller or not
+    def is_raid_controller(self, raid_controller_fqdd, raid_controllers=None):
+        """Determine if the given controller is a RAID controller
+
+        Since a BOSS controller is a type of RAID controller, this method will
+        return True for both BOSS and RAID controllers.
 
         :param raid_controller_fqdd: The object's fqdd we are testing to see
                                      if it is a raid controller or not.
+        :param raid_controllers: A list of RAIDControllers used to check for
+                                 the presence of BOSS cards.  If None, the
+                                 iDRAC will be queried for the list of
+                                 controllers.
         :returns: boolean, True if the device is a RAID controller,
                   False if not.
         """
-        return self._raid_mgmt.is_raid_controller(raid_controller_fqdd)
+        return self._raid_mgmt.is_raid_controller(raid_controller_fqdd,
+                                                  raid_controllers)
 
     def is_boss_controller(self, raid_controller_fqdd):
         """Find out if a RAID controller a BOSS card or not
@@ -1170,11 +1237,11 @@
                              expected_return_value=utils.RET_SUCCESS,
                              wait_for_idrac=False)
 
-        message_id = utils.find_xml(result,
-                                    'MessageID',
-                                    uris.DCIM_LCService).text
+        lc_status = utils.find_xml(result,
+                                   'LCStatus',
+                                   uris.DCIM_LCService).text
 
-        return message_id == IDRAC_IS_READY
+        return lc_status == IDRAC_IS_READY
 
     def wait_until_idrac_is_ready(self, retries=None, retry_delay=None):
         """Waits until the iDRAC is in a ready state
