--- /usr/lib/python2.7/site-packages/dracclient/resources/raid.py	2019-05-09 15:37:11.450522239 +0000
+++ raid.py	2019-05-09 15:37:04.219391200 +0000
@@ -12,6 +12,7 @@
 #    under the License.
 
 import collections
+import copy
 import logging
 
 from dracclient import constants
@@ -34,6 +35,11 @@
 
 REVERSE_RAID_LEVELS = dict((v, k) for (k, v) in RAID_LEVELS.items())
 
+RAID_CONTROLLER_IS_REALTIME = {
+    '1': True,
+    '0': False
+}
+
 DISK_RAID_STATUS = {
     '0': 'unknown',
     '1': 'ready',
@@ -110,7 +116,8 @@
 
 RAIDController = collections.namedtuple(
     'RAIDController', ['id', 'description', 'manufacturer', 'model',
-                       'primary_status', 'firmware_version', 'bus'])
+                       'primary_status', 'firmware_version', 'bus',
+                       'supports_realtime'])
 
 VirtualDiskTuple = collections.namedtuple(
     'VirtualDisk',
@@ -191,7 +198,10 @@
                                                'PrimaryStatus')],
             firmware_version=self._get_raid_controller_attr(
                 drac_controller, 'ControllerFirmwareVersion'),
-            bus=self._get_raid_controller_attr(drac_controller, 'Bus'))
+            bus=self._get_raid_controller_attr(drac_controller, 'Bus'),
+            supports_realtime=RAID_CONTROLLER_IS_REALTIME[
+                self._get_raid_controller_attr(
+                    drac_controller, 'RealtimeCapability')])
 
     def _get_raid_controller_attr(self, drac_controller, attr_name):
         return utils.get_wsman_resource_attr(
@@ -572,24 +582,41 @@
 
         return is_jbod_capable
 
-    def is_raid_controller(self, raid_controller_fqdd):
+    def is_raid_controller(self, raid_controller_fqdd, raid_controllers=None):
         """Find out if object's fqdd is for a raid controller or not
 
         :param raid_controller_fqdd: The object's fqdd we are testing to see
                                      if it is a raid controller or not.
+        :param raid_controllers: A list of RAIDControllers used to check for
+                                 the presence of BOSS cards.  If None, the
+                                 iDRAC will be queried for the list of
+                                 controllers.
         :returns: boolean, True if the device is a RAID controller,
                   False if not.
         """
-        return raid_controller_fqdd.startswith('RAID.')
+        return raid_controller_fqdd.startswith('RAID.') or \
+            self.is_boss_controller(raid_controller_fqdd, raid_controllers)
 
-    def is_boss_controller(self, raid_controller_fqdd):
+    def is_boss_controller(self, raid_controller_fqdd, raid_controllers=None):
         """Find out if a RAID controller a BOSS card or not
 
         :param raid_controller_fqdd: The object's fqdd we are testing to see
                                      if it is a BOSS card or not.
+        :param raid_controllers: A list of RAIDController to scan for presence
+                                 of BOSS card, if None the drac will be queried
+                                 for the list of controllers which will then be
+                                 scanned.
         :returns: boolean, True if the device is a BOSS card, False if not.
+        :raises: WSManRequestFailure on request failures
+        :raises: WSManInvalidResponse when receiving invalid response
+        :raises: DRACOperationFailed on error reported back by the DRAC
+                 interface
         """
-        return raid_controller_fqdd.startswith('AHCI.')
+        if raid_controllers is None:
+            raid_controllers = self.list_raid_controllers()
+        boss_raid_controllers = [
+            c.id for c in raid_controllers if c.model.startswith('BOSS')]
+        return raid_controller_fqdd in boss_raid_controllers
 
     def _check_disks_status(self, mode, physical_disks,
                             controllers_to_physical_disk_ids):
@@ -607,15 +634,17 @@
         :param mode: constants.RaidStatus enumeration used to
                      determine what raid status to check for.
         :param physical_disks: all physical disks
-        :param controllers_to_physical_disk_ids: Dictionary of controllers
-                     we are inspecting and creating jobs for when needed. If
-                     needed modify this dict so that only drives that need to
-                     be changed to RAID or JBOD are in the list of disk keys
-                     for corresponding controller.
+        :param controllers_to_physical_disk_ids: Dictionary of controllers and
+               corresponding disk ids to convert to the requested mode.
+        :returns: a dictionary mapping controller FQDDs to the list of
+                  physical disks that need to be converted for that controller.
         :raises: ValueError: Exception message will list failed drives and
                      drives whose state cannot be changed at this time, drive
                      state is not "ready" or "non-RAID".
         """
+        controllers_to_physical_disk_ids = copy.deepcopy(
+            controllers_to_physical_disk_ids)
+
         p_disk_id_to_status = {}
         for physical_disk in physical_disks:
             p_disk_id_to_status[physical_disk.id] = physical_disk.raid_status
@@ -674,34 +703,37 @@
 
             raise ValueError(error_msg)
 
+        return controllers_to_physical_disk_ids
+
     def change_physical_disk_state(self, mode,
                                    controllers_to_physical_disk_ids=None):
-        """Convert disks RAID status and return a list of controller IDs
+        """Convert disks RAID status
 
-        Builds a list of controller ids that have had disks converted to the
-        specified RAID status by:
-        - Examining all the disks in the system and filtering out any that are
-          not attached to a RAID/BOSS controller.
-        - Inspect the controllers' disks to see if there are any that need to
-          be converted, if so convert them. If a disk is already in the desired
-          status the disk is ignored. Also check for failed or unknown disk
-          statuses and raise an exception where appropriate.
-        - Return a list of controller IDs for controllers whom have had any of
-          their disks converted, and whether a reboot is required.
+        This method intelligently converts the requested physical disks from
+        RAID to JBOD or vice versa.  It does this by only converting the
+        disks that are not already in the correct state.
 
-        The caller typically should then create a config job for the list of
-        controllers returned to finalize the RAID configuration.
-
-        :param mode: constants.RaidStatus enumeration used to determine what
-                     raid status to check for.
+        :param mode: constants.RaidStatus enumeration that indicates the mode
+                     to change the disks to.
         :param controllers_to_physical_disk_ids: Dictionary of controllers and
-               corresponding disk ids we are inspecting and creating jobs for
-               when needed.
-        :returns: a dict containing the following key/values:
+               corresponding disk ids to convert to the requested mode.
+        :returns: a dictionary containing:
+                  - conversion_results, a dictionary that maps controller ids
+                    to the conversion results for that controller.  The
+                    conversion results are a dict that contains:
+                    - The is_commit_required key with the value always set to
+                      True indicating that a config job must be created to
+                      complete disk conversion.
+                    - The is_reboot_required key with a RebootRequired
+                      enumerated value indicating whether the server must be
+                      rebooted to complete disk conversion.
+                  Also contained in the main dict are the following key/values,
+                  which are deprecated, should not be used, and will be removed
+                  in a future release:
                   - is_reboot_required, a boolean stating whether a reboot is
-                  required or not.
+                    required or not.
                   - commit_required_ids, a list of controller ids that will
-                  need to commit their pending RAID changes via a config job.
+                    need to commit their pending RAID changes via a config job.
         :raises: DRACOperationFailed on error reported back by the DRAC and the
                  exception message does not contain NOT_SUPPORTED_MSG constant.
         :raises: Exception on unknown error.
@@ -713,10 +745,11 @@
         if not controllers_to_physical_disk_ids:
             controllers_to_physical_disk_ids = collections.defaultdict(list)
 
+            all_controllers = self.list_raid_controllers()
             for physical_d in physical_disks:
                 # Weed out disks that are not attached to a RAID controller
-                if (self.is_raid_controller(physical_d.controller)
-                        or self.is_boss_controller(physical_d.controller)):
+                if self.is_raid_controller(physical_d.controller,
+                                           all_controllers):
                     physical_disk_ids = controllers_to_physical_disk_ids[
                         physical_d.controller]
 
@@ -727,13 +760,14 @@
         Raise exception if there are any failed drives or
         drives not in status 'ready' or 'non-RAID'
         '''
-        self._check_disks_status(mode, physical_disks,
-                                 controllers_to_physical_disk_ids)
+        final_ctls_to_phys_disk_ids = self._check_disks_status(
+                mode, physical_disks, controllers_to_physical_disk_ids)
 
         is_reboot_required = False
         controllers = []
+        controllers_to_results = {}
         for controller, physical_disk_ids \
-                in controllers_to_physical_disk_ids.items():
+                in final_ctls_to_phys_disk_ids.items():
             if physical_disk_ids:
                 LOG.debug("Converting the following disks to {} on RAID "
                           "controller {}: {}".format(
@@ -746,20 +780,52 @@
                     if constants.NOT_SUPPORTED_MSG in str(ex):
                         LOG.debug("Controller {} does not support "
                                   "JBOD mode".format(controller))
-                        pass
+                        controllers_to_results[controller] = \
+                            utils.build_return_dict(
+                                doc=None,
+                                resource_uri=None,
+                                is_commit_required_value=False,
+                                is_reboot_required_value=constants.
+                                RebootRequired.false)
                     else:
                         raise
                 else:
-                    if conversion_results:
-                        reboot_true = constants.RebootRequired.true
-                        reboot_optional = constants.RebootRequired.optional
-                        _is_reboot_required = \
-                            conversion_results["is_reboot_required"]
-                        is_reboot_required = is_reboot_required \
-                            or (_is_reboot_required
-                                in [reboot_true, reboot_optional])
-                        if conversion_results["is_commit_required"]:
-                            controllers.append(controller)
+                    controllers_to_results[controller] = conversion_results
 
-        return {'is_reboot_required': is_reboot_required,
+                    # Remove the code below when is_reboot_required and
+                    # commit_required_ids are deprecated
+                    reboot_true = constants.RebootRequired.true
+                    reboot_optional = constants.RebootRequired.optional
+                    _is_reboot_required = \
+                        conversion_results["is_reboot_required"]
+                    is_reboot_required = is_reboot_required \
+                        or (_is_reboot_required
+                            in [reboot_true, reboot_optional])
+                    controllers.append(controller)
+            else:
+                controllers_to_results[controller] = \
+                    utils.build_return_dict(
+                        doc=None,
+                        resource_uri=None,
+                        is_commit_required_value=False,
+                        is_reboot_required_value=constants.
+                        RebootRequired.false)
+
+        return {'conversion_results': controllers_to_results,
+                'is_reboot_required': is_reboot_required,
                 'commit_required_ids': controllers}
+
+    def is_realtime_supported(self, raid_controller_fqdd):
+        """Find if controller supports realtime or not
+
+        :param raid_controller_fqdd: ID of RAID controller
+        :returns: True or False
+        """
+        drac_raid_controllers = self.list_raid_controllers()
+        realtime_controller = [cnt.id for cnt in drac_raid_controllers
+                               if cnt.supports_realtime]
+
+        if raid_controller_fqdd in realtime_controller:
+            return True
+
+        return False
